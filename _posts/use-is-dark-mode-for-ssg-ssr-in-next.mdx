---
title: "A useIsDarkMode Hook For Next.js"
abstract: "A hook to ensure client theme preferences are only accessed after hydration"
lastUpdated: "October 16, 2022"
slug: use-is-dark-mode-for-ssg-ssr-in-next
tags:
  - software eng
  - react
  - nextjs
collection: null
---

# A useIsDarkMode Hook For Server-Rendered Pages in Next.js

Implementing a dark mode is surprisingly difficult when dealing with server-rendered content - what's up with all of those `window is undefined` errors during build/request time? It turns out that to write a working `useIsDarkMode` hook, you need a solid knowledge of the rendering cycle used in Next.js: the process of how your app is generated on the server, hydrates on the client, and when you can and cannot access client-level apis. By the end of this post, you should have a solid grasp of all those concepts.

Just a disclaimer: the following hook _won't_ allow you detect the client's os-level theme preference (or any preferences previously saved to local storage) on the server, but it will safely access these preferences during hydration and rerender the page with the correct theme if necessary.

<Info>
  Note: All the relevant concepts in this post apply to server-side rendering as
  well as static site generation - there are meaningful differences between the
  two, but not meaningful for our purposes
</Info>

## tl;dr:

<Code language="tsx" code={`
const key = "isDarkMode";
const defaultValue = false;
export default function useIsDarkMode() {
  const [isDarkMode, setIsDarkMode] = useState(defaultValue);
  const isFirstRender = useRef(true);

  useEffect(() => {
    if (isFirstRender.current) {
      isFirstRender.current = false;

      const item = window.localStorage.getItem(key);
      if (item !== null) {
        setIsDarkMode(JSON.parse(item));
      } else {
        const media = window.matchMedia("(prefers-color-scheme: dark)");
        if (media.matches) {
          setIsDarkMode(true);
        } else {
          setIsDarkMode(false);
        }
      }
    } else {
      window.localStorage.setItem(key, JSON.stringify(isDarkMode));
    }
  }, [isFirstRender, isDarkMode]);

  return [isDarkMode, setIsDarkMode] as const;
}
`} />

or the "safe" version:

<Code language="tsx" code={`
const key = "isDarkMode";
const defaultValue = false;
export default function useIsDarkMode() {
  const [isDarkMode, setIsDarkMode] = useState(defaultValue);
  const isFirstRender = useRef(true);

  const safelySetStorage = useCallback((valueToStore: string) => {
    try {
      window.localStorage.setItem(key, valueToStore);
    } catch (e) {}
  }, []);

  const safelyGetStorage = useCallback((defaultValue: boolean) => {
    let item: boolean;
    try {
      item = JSON.parse(window.localStorage.getItem(key) || "null");
    } catch (e) {
      item = defaultValue;
    }
    return item;
  }, []);

  useEffect(() => {
    if (isFirstRender.current) {
      isFirstRender.current = false;

      const item = safelyGetStorage(defaultValue);
      if (item !== null) {
        setIsDarkMode(item);
      } else {
        const media = window.matchMedia("(prefers-color-scheme: dark)");
        if (media.matches) {
          setIsDarkMode(true);
        } else {
          setIsDarkMode(false);
        }
      }
    } else {
      safelySetStorage(JSON.stringify(isDarkMode));
    }
  }, [isFirstRender, isDarkMode, safelySetStorage, safelyGetStorage]);

return [isDarkMode, setIsDarkMode] as const;
}
`} />

## The Basics of Server Rendering and Hydration

As a refresher, the rough lifecycle of a server generated page in Next.js goes something like the following:

At build time (or request time, if you're using `getServerSideProps`), Next will generate html for each page in the `pages` directory by running the components exported from each file. _However_, Next will only run code needed to generate the html from the first render. Since a `useEffect` runs after the render, this means any code in a `useEffect` is not run on the server at build/request time!

At request time (when the user visits your url), Next sends the user the html generated during build/request time. Next will then rerun your component on the _client_ and ensure that the resulting dom is the same as the html generated on the server (if it's not, Next will give you a warning). At this point, we have the same dom that was generated on the server, but all the javascript associated with creating state, binding events, etc. is in place as well.

Finally, Next will run the code in your `useEffect`s, and update the dom if needed. This whole process of Next rerunning the component on the client is known as hydration.

## The Problems With Server Rendering

Since the html returned to the user at request time is generated on the server at build/request time, it cannot be generated based on any information contained on the client. Unfortunately, this includes local storage - where we'll store the user's theme preference - and media queries - how we check if the user has an os-level theme preference.

In other words, we have _no way to know_ what theme to render when generating our html on the server. There's just no way to get around that. Fortunately, once Next hydrates the page, we can access both media quries and local storage (remember that hydration occurs on the client).

However, to ensure that we only call a media query or access local storage once the page is hydrated, we need need to wrap these calls in a `useEffect`. Otherwise, we'll get an error during build/request time that `window` is `undefined`.

In practice, this gives us the following hook:

<Code language="tsx" code={`
const key = "isDarkMode";
const defaultValue = false;
export default function useIsDarkMode() {
  const [isDarkMode, setIsDarkMode] = useState(defaultValue);
  const isFirstRender = useRef(true);

  useEffect(() => {
    if (isFirstRender.current) {
      isFirstRender.current = false;

      const item = window.localStorage.getItem(key);
      if (item !== null) {
        setIsDarkMode(JSON.parse(item));
      } else {
        const media = window.matchMedia("(prefers-color-scheme: dark)");
        if (media.matches) {
          setIsDarkMode(true);
        } else {
          setIsDarkMode(false);
        }
      }
    } else {
      window.localStorage.setItem(key, JSON.stringify(isDarkMode));
    }
  }, [isFirstRender, isDarkMode]);

return [isDarkMode, setIsDarkMode] as const;
}
`} />

Let's go through the lifecycle of this hook when it's run in a component.

1. The component is rendered, meaning the code in the component is run
2. `useIsDarkMode` is called, which just returns the default value for the `isDarkMode` state, and the setter
3. The component finishes rendering
4. The `useEffect` in `useIsDarkMode` is called, since `useEffect` always runs after the first render
5. `isFirstRender.curent` is `true`, since that's the default value. We set the `isFirstRender.current` to `false` for any subsequent renders. We fetch the data from local storage associated with our `key`. If the `item` is not `null`, this means the user set a theme preference in a previous session. Let's follow that preference and set the state. If the `item` is `null`, the local storage has never been set before. Let's check if there's an os-level theme preference with the media query `prefers-color-scheme: dark`. If they prefer dark mode, let's set the state to `true`, otherwise, if they prefer light mode or don't have an os-level preference, let's set the state to `false`
6. The setter call in the previous step updates the `isDarkMode` state, which triggers a rerender.
7. The component finishes rendering with the new state, possibly updating the color theme based on the result from step 5
8. The `useEffect` in `useIsDarkMode` is called, since `isDarkMode` is in the dependency array
9. `isFirstRender.current` is `false`, since we set to `false` the last time the `useEffect` ran
10. We save the current theme to local storage for reference in a future session

Looks good! If you want to account for potential errors when accessing the user's local storage, feel free to use these "safe" getters and setters instead.

<Code language="tsx" code={`
const safelySetStorage = useCallback((valueToStore: string) => {
  try {
    window.localStorage.setItem(key, valueToStore);
  } catch (e) {}
}, []);

const safelyGetStorage = useCallback((defaultValue: boolean) => {
  let item: boolean;
  try {
    item = JSON.parse(window.localStorage.getItem(key) || "null");
  } catch (e) {
    item = defaultValue;
  }
  return item;
}, []);
`} />

Both functions are wrapped in `useCallback` so they can be added to the dependency array of the `useEffect`.

## Bonus

If you enjoyed this post, I'd recommend checking out [this video](https://www.youtube.com/watch?v=d2yNsZd5PMs) by Theo of ping.gg - it's a really great explanation of the concepts discussed here, plus more!
