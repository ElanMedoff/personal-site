---
title: "A useIsDarkMode Hook For Sever-Rendered Pages in Next.js"
abstract: "A hook to managed your dark mode while ensuring client preferences are only accessed after hydration"
lastUpdated: "October 16, 2022"
slug: use-is-dark-mode-for-ssg-ssr-in-next
tags:
  - software eng
  - react
  - nextjs
collection: null
---

# A useIsDarkMode Hook For Server-Rendered Pages in Next.js

Implementing a dark mode is surprisingly difficult when dealing with server-rendered content. Although the following hook _won't_ allow you detect the client's os-level theme preference (or any preferences previously saved to local storage) on the server, it will access these preferences during hydration and rerender the page with the correct theme if necessary.

<Info>
  Note: All the relevant concepts in this post apply to server-side rendering as
  well as static site generation - there are meaningful differences between the
  two, but not meaningful for our purposes
</Info>

## tl;dr:

<Code language="tsx" code={`
const key = "isDarkMode";
const defaultValue = false;
export default function useIsDarkMode() {
  const [isDarkMode, setIsDarkMode] = useState(defaultValue);
  const isFirstRender = useRef(true);

  useEffect(() => {
    if (isFirstRender.current) {
      isFirstRender.current = false;

      const item = window.localStorage.getItem(key);
      if (item !== null) {
        setIsDarkMode(JSON.parse(item));
      } else {
        const media = window.matchMedia("(prefers-color-scheme: dark)");
        if (media.matches) {
          setIsDarkMode(true);
        } else {
          setIsDarkMode(false);
        }
      }
    } else {
      window.localStorage.setItem(key, JSON.stringify(isDarkMode));
    }
  }, [isFirstRender, isDarkMode]);

  return [isDarkMode, setIsDarkMode] as const;
}
`} />

or the "safe" version:

<Code language="tsx" code={`
const key = "isDarkMode";
const defaultValue = false;
export default function useIsDarkMode() {
  const [isDarkMode, setIsDarkMode] = useState(defaultValue);
  const isFirstRender = useRef(true);

  const safelySetStorage = useCallback((valueToStore: string) => {
    try {
      window.localStorage.setItem(key, valueToStore);
    } catch (e) {}
  }, []);

  const safelyGetStorage = useCallback((defaultValue: boolean) => {
    let item: boolean;
    try {
      item = JSON.parse(window.localStorage.getItem(key) || "null");
    } catch (e) {
      item = defaultValue;
    }
    return item;
  }, []);

  useEffect(() => {
    if (isFirstRender.current) {
      isFirstRender.current = false;

      const item = safelyGetStorage(defaultValue);
      if (item !== null) {
        setIsDarkMode(item);
      } else {
        const media = window.matchMedia("(prefers-color-scheme: dark)");
        if (media.matches) {
          setIsDarkMode(true);
        } else {
          setIsDarkMode(false);
        }
      }
    } else {
      safelySetStorage(JSON.stringify(isDarkMode));
    }
  }, [isFirstRender, isDarkMode, safelySetStorage, safelyGetStorage]);

return [isDarkMode, setIsDarkMode] as const;
}
`} />

## The Basics of SSG

As a refresher, the rough lifecycle of a server generated page in Next.js goes something like the following:

At build time (`npm run build`), Next will generate html for each page in the `pages` directory by running the components exported from each file. _However_, Next will only run code relevant for the first render, and nothing after. Since a `useEffect` runs after the render, this means any code in a `useEffect` is not run on the server during build time!

At request time (when the user visits your url), Next sends the user the html generated during build time. Next will then rerun your component on the _client_ and ensure that the resulting dom is the same as the html built at build time on the server (if it's not, Next will give you a warning). At this point, we have the same dom that was generated on the server, but all the javascript associated with creating state, binding events, etc. is in place as well.

Finally, Next will run the code in your `useEffect`s, and update the dom if needed. This whole process of Next rerunning the component on the client is known as hydration.

## The Problems With SSG and How UseEffect Comes to the Rescue

Since the html returned to the user at request time is generated on the server at build time, it cannot be generated based on any information contained on the client. Unfortunately, this includes local storage - where we'll store the user's theme preference - and media queries - how we check if the user has an os-level theme preference.

In other words, we have _no way to know_ what theme to render when generating our html at build time. There's no way to get around that. Fortunately, once Next hydrates the page, we can access both media quries and local storage (remember that hydration occurs on the client).

However, to ensure that we only call a media query or access local storage once the page is hydrated, we need need to wrap these calls in a `useEffect`. Otherwise, we'll get an error during build time that `window` is `undefined`.

In practice, this gives us the following hook:

<Code language="tsx" code={`
const key = "isDarkMode";
const defaultValue = false;
export default function useIsDarkMode() {
  const [isDarkMode, setIsDarkMode] = useState(defaultValue);
  const isFirstRender = useRef(true);

  useEffect(() => {
    if (isFirstRender.current) {
      isFirstRender.current = false;

      const item = window.localStorage.getItem(key);
      if (item !== null) {
        setIsDarkMode(JSON.parse(item));
      } else {
        const media = window.matchMedia("(prefers-color-scheme: dark)");
        if (media.matches) {
          setIsDarkMode(true);
        } else {
          setIsDarkMode(false);
        }
      }
    } else {
      window.localStorage.setItem(key, JSON.stringify(isDarkMode));
    }
  }, [isFirstRender, isDarkMode]);

return [isDarkMode, setIsDarkMode] as const;
}
`} />

Let's go through the lifecycle of this hook when it's run in a component.

1. The component is rendered, meaning the code in the component is run
2. `useIsDarkMode` is called, which just returns the default value for the `isDarkMode` state, and the setter
3. The component finishes rendering
4. The `useEffect` in `useIsDarkMode` is called, since `useEffect` always runs after the first render
5. `isFirstRender.curent` is `true`, since that's the default value. We set the `isFirstRender.current` to `false` for any subsequent renders. We fetch the data from local storage associated with our `key`. If the `item` is not `null`, this means the user set a theme preference in a previous session. Let's follow that preference and set the state. If the `item` is `null`, the local storage has never been set before. Let's check if there's an os-level theme preference with the media query `prefers-color-scheme: dark`. If they prefer dark mode, let's set the state to `true`, otherwise, if they prefer light mode or don't have an os-level preference, let's set the state to `false`
6. The setter call in the previous step updates the `isDarkMode` state, which triggers a rerender.
7. The component finishes rendering with the new state, possibly updating the color theme based on the result from step 5
8. The `useEffect` in `useIsDarkMode` is called, since `isDarkMode` is in the dependency array
9. `isFirstRender.current` is `false`, since we set to `false` the last time the `useEffect` ran
10. We save the current theme to local storage for reference in a future session

Looks good! If you want to account for potential errors when accessing the user's local storage, feel free to use these "safe" getters and setters instead.

<Code language="tsx" code={`
const safelySetStorage = useCallback((valueToStore: string) => {
  try {
    window.localStorage.setItem(key, valueToStore);
  } catch (e) {}
}, []);

const safelyGetStorage = useCallback((defaultValue: boolean) => {
  let item: boolean;
  try {
    item = JSON.parse(window.localStorage.getItem(key) || "null");
  } catch (e) {
    item = defaultValue;
  }
  return item;
}, []);
`} />

Both functions are wrapped in `useCallback` so they can be added to the dependency array of the `useEffect`.
