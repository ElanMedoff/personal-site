{"pageProps":{"post":{"content":"\n# Data Fetching in React: Parent-Agnostic vs Parent-Dependent Children\n\nData fetching in React is a popular topic of blog posts, dev talks, and tutorials – and for good reason. Asynchronous data fetching introduces a whole collection of complexities to handle. I hope to contribute with a less-often discussed topic: the role of the children whose parent fetches data asynchronously, and to what extent the children should account for this behavior.\n\n## Preamble: basic inline null checking\n\nTake the following snippet:\n\n```tsx\ninterface Data {\n  price: number;\n}\n\nfunction Parent() {\n  const [data, setData] = useState<Data | null>(null);\n\n  useEffect(() => {\n    const load = async () => {\n      try {\n        const data: Data = await getData();\n        setData(data);\n      } catch (e) {\n        console.error(e);\n      }\n    };\n\n    load();\n  }, []);\n\n  return null;\n}\n```\n\nNow consider a case where the `Parent` wants to render markup based on the data fetched with `getData`.\n\n```tsx\nfunction Parent() {\n  const [data, setData] = useState<Data | null>(null);\n\n  useEffect(() => {\n    // ...\n  }, []);\n\n  return <>{data.price}</>;\n}\n```\n\nBecause a `useEffect` runs _after_ the render, there's at least one render (i.e. the first) where `data` is still its initial value, `null`. This means, one way or another, we have to account for a `null` instance of `data` – otherwise, React will crash when we try to access `(null).number`.\n\n<div data-daisy=\"alert\">\n\nI'd highly recommend checking out Dan Abramov's [A Complete Guide to useEffect](https://overreacted.io/a-complete-guide-to-useeffect/) <span data-daisy=\"aside\">[external link]</span> if the mechanics of `useEffect` aren't so clear to you.\n\n</div>\n\nOne popular option is to perform inline null checking.\n\n```tsx\nfunction Parent() {\n  const [data, setData] = useState<Data | null>(null);\n\n  useEffect(() => {\n    // ...\n  }, []);\n\n  return <>{data?.price}</>;\n}\n```\n\nWith optional chaining in place, when `data` is `null`, accessing `data?.price` will return `undefined` instead of throwing an error. This pattern takes advantage of the fact that, if an expression passed to a `{}` in React \"resolves\" to `null` or `undefined`, React will gracefully (i.e. without throwing an error) render nothing.\n\n## A more complicated case\n\nOptional chaining works fine for simple cases like above, but what about when we want to perform actions on the data that depend on its type? Consider if we'd like to format the `price` field to two decimal places:\n\n```tsx\nfunction Parent() {\n  const [data, setData] = useState<Data | null>(null);\n\n  useEffect(() => {\n    // ...\n  }, []);\n\n  return <>{data?.price.toFixed(2)}</>;\n}\n```\n\nSince `data` will be null on the first render, `data?.price` will resolve to `undefined`, and we'll end up calling `(undefined).toFixed(2)`, which'll throw.\n\nSimple enough, let's add a fallback value of `0`:\n\n```tsx\nreturn <>{(data?.price ?? 0).toFixed(2)}</>;\n```\n\nAlternatively, we could return early and avoid our optional chaining altogether:\n\n```tsx\nfunction Parent() {\n  const [data, setData] = useState<Data | null>(null);\n\n  useEffect(() => {\n    // ...\n  }, []);\n\n  if (data === null) return;\n\n  return <>{data.price.toFixed(2)}</>;\n}\n```\n\nEither solution works great when we're dealing with a single component, but once we introduce children into the mix, we encounter some deeper questions. Consider our original example, but with a new `FormatNumber` child.\n\n```tsx\nfunction Parent() {\n  const [data, setData] = useState<Data | null>(null);\n\n  useEffect(() => {\n    // ...\n  }, []);\n\n  return <FormatNumber num={data?.price} />;\n}\n\nfunction FormatNumber({ num }: { num: number }) {\n  return <>{num.toFixed(2)}</>;\n}\n```\n\nAs explained above, this code will crash on the first render when `data?.price` resolves to `undefined`, and we pass `undefined` as `num` to `FormatNumber`.\n\nThere are three possible fixes, two of which we already discussed:\n\n```tsx\nfunction Parent() {\n  const [data, setData] = useState<Data | null>(null);\n\n  useEffect(() => {\n    // ...\n  }, []);\n\n  // option 1 (old: return early)\n  if (data === null) return;\n  return <FormatNumber num={data.price} />;\n\n  // option 2 (old: inline null checking with a fallback value)\n  return <FormatNumber num={data?.price ?? 0} />;\n}\n\nfunction FormatNumber({ num }: { num: number }) {\n  // option 3 (new: null checking in the child)\n  if (typeof num !== \"number\") return;\n  return <>{num.toFixed(2)}</>;\n}\n```\n\nNow that we're dealing with two components, we have the option to null check in the parent _or_ in the child – option 1 and option 2 null check in parent, and option 3 null checks in the child. This leads us to a deeper, more interesting question on best-practices:\n\n**Who should be responsible for null checking?** The parent, or the child? This question is at the crux of this article; let's explore both approaches.\n\n## Parent-dependent children\n\nA Parent-dependent child relies on it's parent to do it's null checking for them. It has no null checking of it's own, and it expects it's props to always be populated and of the correct type. Otherwise, it may throw.\n\nIn our example above, this would mean the `Parent` should return early, ensuring that when `FormatNumber` _is_ rendered, its `num` prop is always populated and a `number`.\nAlternatively, the `Parent` could perform inline null checking with a fallback value and achieve the same result.\n\nIt's worth nothing that if the child's prop is a more complicated data structure, such as a series of nested objects, passing a fallback value like `?? 0` isn't always an option.\n\n## Parent-agnostic children\n\nIn contrast to a Parent-dependent child, a Parent-agnostic child expects no null checking from it's parent. Maybe the parent will null check before rendering the child, maybe it won't - the Parent-agnostic child won't rely on either behavior. Instead, the Parent-agnostic child will perform it's own null checking, gracefully handling every case on its own.\n\nIn our example above, `FormatNumber` would have its own null checking, maybe something like:\n\n```tsx\nfunction FormatNumber({ num: number }) {\n  if (typeof num !== \"number\") return;\n  return <>{num.toFixed(2)}</>;\n}\n```\n\n<div data-daisy=\"alert\">\n\n**Note**: when null checking a number or string, a simple `if (!prop)` check is mostly likely _not_ what you want – it will return `false` with `0` or `\"\"`!\n\n</div>\n\n## So which is best?\n\nI would argue that, in an ideal world, we would all write Parent-dependent children. The child shouldn't have to worry about being passed nullish (`null` or `undefined`) values: it clearly defines that it expects non-nullish props in its type! If you're consuming an api (i.e. a child component) in your parent, it should be _your_ responsibility to call that child with the props it expects.\n\nUnfortunately, this approach isn't always feasible. In the same way we're taught to never trust, and always validate, user input, the author of a child component should never expect that the parent will call it correctly. Anything else would be much too optimistic.\n\nBut what if there was a way for the child to guarantee that the parent would pass it the correct props, without needing any extra code to verify the fact? It seems to0 good to be true, but that's exactly what we can do with [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks) enabled.\n\n## strict null checks\n\nIn the words of the TypeScript docs:\n\n<div data-daisy=\"alert\">\n\nWhen `strictNullChecks` is `true`, `null` and `undefined` have their own distinct types and you’ll get a type error if you try to use them where a concrete value is expected.\n\n</div>\n\nWith `strictNullChecks` enabled, let's go back to our example and try to perform inline null checking in the parent:\n\n```tsx\nfunction Parent() {\n  const [data, setData] = useState<Data | null>(null);\n\n  useEffect(() => {\n    // ...\n  }, []);\n\n  /*\n   Compile time ts error:\n   Type 'number | undefined' is not assignable to type 'number'.\n      Type 'undefined' is not assignable to type 'number'.\n  */\n  return <FormatNumber num={data?.id} />;\n}\n\n// Parent-dependent variation (without it's own null checks)\nfunction FormatNumber({ num: number }) {\n  return <>{num.toFixed(2)}</>;\n}\n```\n\nTypeScript now gives us a compile time error that `data?.id` may be `undefined`, and `FormatNumber`'s `num` prop can only be a `number`!\n\nTo fix this error, we can either return early, or modify our inline null checking to use a fallback value.\n\nIt's important to note that, from the perspective of the parent, little has changed: you still have to return early or perform inline null checking. TypeScript won't save you any code, or advise you to choose one over the other. All of that's true.\n\nBut from the perspective of the child, this makes a _huge_ difference. With `strictNullChecks` enabled, the child can have the clean code of a Parent-dependent child (i.e. without any null checks of its own) with the safety guarantees of a Parent-agnostic child – if a parent tries to pass the child a prop not explicitly described in the child's type (like a nullish prop), TypeScript will throw an error!\n\n## When strict null checks aren't available\n\n`strictNullChecks` are a great solution when your codebase in written in TypeScript, but for when you're working in JavaScript, or for one reason or another you have to keep `strictNullChecks` disabled, there are a few considerations I try to keep in mind when deciding between writing Parent-dependent and Parent-agnostic children.\n\nIs the child a general-purpose component designed to be used by multiple parents, or a one-off written for a single case? If the former, I tend to air on the side of writing Parent-agnostic children – as we discussed above, it's best not to rely on a consumer of your component null checking for you (whether that be yourself or someone else working on the codebase).\n\nOn the other hand, if the child is only used by a single parent, that may be a better case for writing a Parent-dependent child. The mental effort of remembering to pass non-nullish values to the child (either by returning early, or passing a fallback value when performing inline null checking), may be worth the code saved by making the child Parent-dependent.\n\nIt's not ideal, but for situations where we have to rely on best practices instead of compile-time checks, all you can do is use your best judgement.\n","metadata":{"title":"Data Fetching in React: Parent-Agnostic vs Parent-Dependent Children","abstract":"Null checking: who should have to do it? The child, or the parent?","lastUpdated":"July 27, 2022","slug":"Parent-dependent-and-parent-agnostic-children","tags":["react","software eng"]}},"relatedPostMetadata":{"title":"Data Fetching in React: Parent-Agnostic vs Parent-Dependent Children","abstract":"Null checking: who should have to do it? The child, or the parent?","lastUpdated":"July 27, 2022","slug":"Parent-dependent-and-parent-agnostic-children","tags":["react","software eng"]}},"__N_SSG":true}