---
title: "Dark Mode in Next.js: A Client-Side Approach With LocalStorage"
abstract: "Ensure client theme preferences are only accessed after hydration"
lastUpdated: "October 16, 2022"
slug: dark-mode-next-js-client-side-approach
tags:
  - software eng
  - react
  - nextjs
collection:
  name: "dark-mode"
  order: 0
isPublished: true
---

# Dark Mode in Next.js: A Client-Side Approach

Implementing a dark mode hook is a deceptively difficult task when dealing with server-rendered content. You'll want to access a client's os-level theme preference through a media query, persist a chosen theme through local storage or cookies, and ensure that browser and server-specific apis are only used when they can be safely accessed. 

As you can imagine, there's many different approaches you can take - but I'll boil it down to two. In this article, we'll talk about the first: a client-side approach using media queries to access os-level preferences, and local storage to save any manually-set preferences. The crux of this approach is to access the saved/os-level theme after the first render, and rerender the page if necessary.

In the next <Link href="/blog/dark-mode-next-js-server-side-approach">article</Link>, we'll take a server-side approach, using cookies to store a client's chosen theme preference, while ignoring any os-level preferences. In the <Link href="blog/dark-mode-next-js-server-side-approach#bonus-accounting-for-an-os-level-theme-preference">Bonus</Link>, I'll discuss a hybrid approach to account for os-level preferences using both cookies and media queries, careful to only use a media query after the first render.

With that introduction out of the way, let's get started!

<Info>
  Note: All the relevant concepts in this post apply to server-side rendering as
  well as static site generation - there are meaningful differences between the
  two, but not meaningful for our purposes
</Info>

## tl;dr:

<Code language="tsx" code={`
import { useEffect, useRef, useState } from "react";

const key = "isDarkMode";
export default function useIsDarkMode() {
  const [isDarkMode, setIsDarkMode] = useState(false);
  const isFirstRender = useRef(true);

  useEffect(() => {
    if (isFirstRender.current) {
      isFirstRender.current = false;

      const item = window.localStorage.getItem(key);
      if (item !== null) {
        setIsDarkMode(JSON.parse(item));
        return;
      }

      const media = window.matchMedia("(prefers-color-scheme: dark)");
      if (media.matches) {
        setIsDarkMode(true);
      } else {
        setIsDarkMode(false);
      }
      return;
    }

    window.localStorage.setItem(key, JSON.stringify(isDarkMode));
  }, [isFirstRender, isDarkMode]);

  return [isDarkMode, setIsDarkMode] as const;
}
`} />

or the "safe" version:

<Code language="tsx" code={`
import { useCallback, useEffect, useRef, useState } from "react";

const key = "isDarkMode";
const defaultValue = false;
export default function useIsDarkMode() {
  const [isDarkMode, setIsDarkMode] = useState(defaultValue);
  const isFirstRender = useRef(true);

  const safelySetStorage = useCallback((valueToStore: string) => {
    try {
      window.localStorage.setItem(key, valueToStore);
    } catch (e) {}
  }, []);

  const safelyGetStorage = useCallback((defaultValue: boolean) => {
    let item: boolean;
    try {
      item = JSON.parse(window.localStorage.getItem(key) || "null");
    } catch (e) {
      item = defaultValue;
    }
    return item;
  }, []);

  useEffect(() => {
    if (isFirstRender.current) {
      isFirstRender.current = false;

      const item = safelyGetStorage(defaultValue);
      if (item !== null) {
        setIsDarkMode(item);
        return;
      }

      const media = window.matchMedia("(prefers-color-scheme: dark)");
      if (media.matches) {
        setIsDarkMode(true);
      } else {
        setIsDarkMode(false);
      }
      return;
    }

    safelySetStorage(JSON.stringify(isDarkMode));
  }, [isFirstRender, isDarkMode, safelySetStorage, safelyGetStorage]);

  return [isDarkMode, setIsDarkMode] as const;
}
`} />

## The Basics of Server Rendering and Hydration

As a refresher, the rough lifecycle of a server generated page in Next.js goes something like the following:

At build time (or request time, if you're using `getServerSideProps`), Next will generate html for each page in the `pages` directory by running the components exported from each file. _However_, Next will only run code needed to generate the html from the first render. Since a `useEffect` runs after the render, this means any code in a `useEffect` is not run on the server at build/request time!

At request time (when the user visits your url), Next sends the user the html generated during build/request time. Next will then rerun your component on the _client_ and ensure that the resulting dom is the same as the html generated on the server (if it's not, Next will give you a warning). At this point, we have the same dom that was generated on the server, but all the javascript associated with creating state, binding events, etc. is in place as well.

Finally, Next will run the code in your `useEffect`s, and update the dom if needed. This whole process of Next rerunning the component on the client is known as hydration.

## The Problems With Server Rendering

Since the html returned to the user at request time is generated on the server at build/request time, it cannot be generated based on any information contained on the client. Unfortunately, this includes local storage - where we'll store the user's theme preference - and media queries - how we check if the user has an os-level theme preference.

This means that for our approach, we have _no way to know_ what theme to render when generating our html on the server. There's just no way to get around that. Fortunately, once Next hydrates the page, we can access both media queries and local storage (remember that hydration occurs on the client).

However, to ensure that we only call a media query or access local storage once the page is hydrated, we need to wrap these calls in a `useEffect`. Otherwise, we'll get an error during build/request time that `window` is `undefined`.

In practice, this gives us the following hook:

<Code language="tsx" code={`
import { useEffect, useRef, useState } from "react";

const key = "isDarkMode";
export default function useIsDarkMode() {
  const [isDarkMode, setIsDarkMode] = useState(false);
  const isFirstRender = useRef(true);

  useEffect(() => {
    if (isFirstRender.current) {
      isFirstRender.current = false;

      const item = window.localStorage.getItem(key);
      if (item !== null) {
        setIsDarkMode(JSON.parse(item));
        return;
      }

      const media = window.matchMedia("(prefers-color-scheme: dark)");
      if (media.matches) {
        setIsDarkMode(true);
      } else {
        setIsDarkMode(false);
      }
      return;
    }

    window.localStorage.setItem(key, JSON.stringify(isDarkMode));
  }, [isFirstRender, isDarkMode]);

  return [isDarkMode, setIsDarkMode] as const;
}
`} />

Let's go through the lifecycle of this hook when it's run in a component.

1. The component is rendered
2. `useIsDarkMode` is called, which just returns the default value for the `isDarkMode` state, and the setter
3. The component finishes rendering
4. The `useEffect` in `useIsDarkMode` is called, since `useEffect` always runs after the first render
5. `isFirstRender.curent` is `true`, since that's the default value. We set the `isFirstRender.current` to `false` for any subsequent renders. We fetch the data from local storage associated with our `key`. If the `item` is not `null`, this means the user set a theme preference in a previous session. Let's follow that preference and set the state. If the `item` is `null`, the local storage has never been set before. Let's check if there's an os-level theme preference with the media query `prefers-color-scheme: dark`. If they prefer dark mode, let's set the state to `true`, otherwise, if they prefer light mode or don't have an os-level preference, let's set the state to `false`
6. The setter call in the previous step updates the `isDarkMode` state, which triggers a rerender.
7. The component finishes rendering with the new state, possibly updating the color theme based on the result from step 5
8. The `useEffect` in `useIsDarkMode` is called, since `isDarkMode` is in the dependency array
9. `isFirstRender.current` is `false`, since we set to `false` the last time the `useEffect` ran
10. We save the current theme to local storage for reference in a future session

Looks good! If you want to account for potential errors when accessing the user's local storage, feel free to use these "safe" getters and setters instead.

<Code language="tsx" code={`
const safelySetStorage = useCallback((valueToStore: string) => {
  try {
    window.localStorage.setItem(key, valueToStore);
  } catch (e) {}
}, []);

const safelyGetStorage = useCallback((defaultValue: boolean) => {
  let item: boolean;
  try {
    item = JSON.parse(window.localStorage.getItem(key) || "null");
  } catch (e) {
    item = defaultValue;
  }
  return item;
}, []);
`} />

Both functions are wrapped in `useCallback` so they can be added to the dependency array of the `useEffect`.

## Bonus

If you enjoyed this post, I'd recommend checking out [this video](https://www.youtube.com/watch?v=d2yNsZd5PMs) by Theo of ping.gg - it's a really great explanation of the concepts discussed here, plus more!
